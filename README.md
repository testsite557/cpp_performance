## task 4: performance computing

### report

| Realization   | 10 func       | 100 func      | 1000 func     | 10000 func    |
|:-------------:|:-------------:|:-------------:|:-------------:|:-------------:|
| Python3       | 4 ms          | 7 ms          | 26 ms         | 228 ms        |
| Numba         | 0 ms          | 0 ms          | 3 ms          | 25 ms         |
| PyPy3         | 6 ms          | 12 ms         | 42 ms         | 132 ms        |
| ctypes        | 1 ms          | 1 ms          | 2 ms          | 12 ms         |
| SWIG          | 0 ms          | 1 ms          | 2 ms          | 6 ms          |

**Python3**

| CPU quantity  | 10 func       | 100 func      | 1000 func     | 10000 func    |
|:-------------:|:-------------:|:-------------:|:-------------:|:-------------:|
| 1 CPU         | 4 ms          | 7 ms          | 26 ms         | 228 ms        |
| 2 CPU         | 1 ms          | 3 ms          | 15 ms         | 129 ms        |

**Numba**

| CPU quantity  | 10 func       | 100 func      | 1000 func     | 10000 func    |
|:-------------:|:-------------:|:-------------:|:-------------:|:-------------:|
| 1 CPU         | 0 ms          | 0 ms          | 3 ms          | 25 ms         |
| 2 CPU         | 0 ms          | 0 ms          | 2 ms          | 19 ms         |


**PyPy3**

| CPU quantity  | 10 func       | 100 func      | 1000 func     | 10000 func    |
|:-------------:|:-------------:|:-------------:|:-------------:|:-------------:|
| 1 CPU         | 6 ms          | 12 ms         | 42 ms         | 132 ms        |
| 2 CPU         | 6 ms          | 14 ms         | 39 ms         | 107 ms        |


**ctypes**

| CPU quantity  | 10 func       | 100 func      | 1000 func     | 10000 func    |
|:-------------:|:-------------:|:-------------:|:-------------:|:-------------:|
| 1 CPU         | 1 ms          | 1 ms          | 2 ms          | 12 ms         |
| 2 CPU         | 1 ms          | 1 ms          | 2 ms          | 7 ms          |


**SWIG**

| CPU quantity  | 10 func       | 100 func      | 1000 func     | 10000 func    |
|:-------------:|:-------------:|:-------------:|:-------------:|:-------------:|
| 1 CPU         | 0 ms          | 1 ms          | 2 ms          | 6 ms          |
| 2 CPU         | 0 ms          | 1 ms          | 1 ms          | 4 ms          |

# Задание 4. Производительные вычисления

### Краткое описание

В задании требуется реализовать требовательную к ресурсам CPU вычислительную функцию, оптимизировать вычисления при помощи различных методов, таких как JIT-компиляция, выполнения C/C++ кода, распараллеливание, затем провести сравнение времени работы данных реализаций и написать выводы.

В качестве вычислительной функции предлагается реализовать вычисление минкода булевой функции.

Проект, включающий в себя код на Python, C/C++, а также сборочные файлы, должен соответствовать требований соответствующих стилей кодирования и иметь адекватную структуру директорий.

### Минкод булевой функции

Кодом булевой функции f(x_1, ..., x_n) назовём десятичное представление её вектора значений. Например, для функции x_1 v x_2 вектор значений равен (0111), а соответветствующий код функции равен 7.

Минкодом булевой функции назовём минимальный код функции, получающейся из исходной при помощи перестановки и отрицаний входных переменных. В качестве примера рассмотрим функцию эквиваленции x_1 ~ x_2 с вектором значений (1001) и кодом 9. Так как функция является симметрической, перестановка переменных не влияет на вектор значений и, соответственно, код функции. Отрицание любой из переменных инвертирует вектор значений. Таким образом, единственной функцией, получаемой из эквиваленции при помощи перестановки и отрицаний переменных и неравной исходной функции, является функция x_1 ^ x_2 с вектором значений (0110) и кодом 6. Значит, минкод функции x_1 ~ x_2 равен 6.

В задании требуется реализовать тривиальный переборный алгоритм вычиcления минкодов. Суть алгоритма в том, что мы перебираем всевозможные перестановки и отрицания переменных функции, вычисляем коды получившихся функции и выбираем из них минимум.

### Требования к реализациям

Будем рассматривать только функции, зависящие не более чем от 5 переменных. В таком случае их векторы значений могут быть представлены в виде 32-х битных беззнаковых чисел.

Реализуемая функция получает на вход количество переменных, а также список (Python), указатель uint32_t* \(C\) или вектор (C++) кодов булевых функций. Функция должна вернуть список, указатель на массив или вектор минкодов данных функций. При использовани указателей не забывайте про освобождение памяти, также разрешается вместо выделения памяти в функции передавать указатель для записи результата или же записывать результат inplace.

Будем сравнивать между собой следующие реализации:
1. Функция на Python, обычный запуск;
2. Функция на Python с JIT-компиляцией при помощи numba;
3. Функция на Python, запуск при помощи интерпретатора PyPy;
4. Функция на C или C++, обёртка при помощи ctypes;
5. Функция на C или C++, обёртка при помощи SWIG.

Алгоритмы вычисления минкодов на Python и C/C++ должны максимально совпадать. Там, где это возможно и осмысленно, рекомендуется использовать битовые вычисления.

Для сравнения производительности сгенерируйте набор из 10, 100, 1000 и 10000 случайных функций от 5 переменных и запустите на них вышеописанные реализации с замером времени работы программы.

### Распараллеливание

Распараллельте реализацию на Python при помощи multiprocessing и numba (это две разных реализации), а реализацию на C/C++ при помощи OpenMP.

Для оценки эффективности распараллеливания будем сравнивать между собой запуски при разном числе процессов: 1, 2, 3, ... . Максимальное количество процессов должно соответствовать количеству ядер (включая hyperthreading) в системе.

### Выводы

Отчёт можно оформить в LaTeX или Markdown. Ниже приводятся примеры таблиц, которые можно использовать в отчёте.

| Реализация    | 10 ф-ций      | 100 ф-ций     | 1000 ф-ций    | 10000 ф-ций   |
|:-------------:|:-------------:|:-------------:|:-------------:|:-------------:|
| Pure Python   | ? мс          | ? мс          | ? мс          | ? мс          |
| Numba         | ? мс          | ? мс          | ? мс          | ? мс          |
| PyPy          | ? мс          | ? мс          | ? мс          | ? мс          |
| ctypes        | ? мс          | ? мс          | ? мс          | ? мс          |
| SWIG          | ? мс          | ? мс          | ? мс          | ? мс          |

| Кол-во CPU    | 10 ф-ций      | 100 ф-ций     | 1000 ф-ций    | 10000 ф-ций   |
|:-------------:|:-------------:|:-------------:|:-------------:|:-------------:|
| 1 CPU         | ? мс          | ? мс          | ? мс          | ? мс          |
| 2 CPU         | ? мс          | ? мс          | ? мс          | ? мс          |
| 3 CPU         | ? мс          | ? мс          | ? мс          | ? мс          |
| 4 CPU         | ? мс          | ? мс          | ? мс          | ? мс          |
